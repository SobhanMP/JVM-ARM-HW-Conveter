\section*{پیاده‌سازی دستورات پردازنده به‌کمک
	اسمبلی
	\lr{ARM}
}

در این مرحله تمامی دستورات پردازنده را با کمک زبان اسمبلی
\lr{ARM}
پیاده‌سازی کردیم. این دستورات شامل موارد زیر می‌شوند:

\subsection*{دستورات ستون دوم شامل کار با استک و اعداد صحیح}

برای پیاده‌سازی دستورات dup و مشابه آن‌ها تنها از دو دستور push و pop استفاده شده‌است. به این شکل که به‌ترتیب ذکرشده در مراجع، موارد مربوطه را push و pop می‌کنیم.

دستورات
\lr{pop}
و
\lr{pop2}
نیز با استفاده از یک خط دستور pop قابل پیاده‌سازی هستند و برای دستور swap نیز مشابه دستورات قبلی عمل می‌کنیم.

\subsection*{دستورات سه ستون دیگر شامل دستورات کار با float و double}

برای کار با اعداد 
\lr{floating point}
در اسمبلی
ARM دستورات مشخصی وجود دارد اما این دستورات توسط coprocessor اجرا می‌شوند. برای این که به coprocessor متصل شویم، از چند خط کد در ابتدای فایل 
\lr{.s}
ارسالی استفاده کرده‌ایم. این خطوط شامل فعال کردن مواردی مانند fpu و اتصال به coprocessor می‌شود.

\subsubsection*{چالش‌های اجرای کدهای اسمبلی نیازمند
\lr{fpu}}
در ابتدا می‌خواستیم شبیه‌سازی دستورات اسمبلی را به کمک
\lr{Keil}
 انجام‌دهیم، اما پس از اندکی تلاش مشاهده‌کردیم که پردازنده‌های دارای
\lr{fpu}،
 از خانواده‌یِ
\lr{cortex-m} 
هستند که تنها دستوراتِ
\lr{Thumb}
  را پشتیبانی می‌کنند اما ما می‌خواستیم که از دستورات ۳۲بیتیِ
\lr{ARM}
   در این پروژه بهره‌ببریم.
  .
  بنابراین تصمیم‌گرفتیم که در این بخش از نرم‌افزار
\lr{DS-5}
   استفاده‌کنیم. پس از نصب نرم‌افزار
\lr{DS-5}
 ابتدا سعی‌کردیم تا به کمک 
\lr{Fast Model}
    شبیه‌سازی را انجام دهیم و با جست‌وجو میان
\lr{Fast Model}ها
 متوجه‌شدیم که باید از پردازنده‌های خانواده‌ی
 \lr{Cortex-A}
 استفاده‌کنیم و در بین این پردازنده‌ها ، پردازنده‌ی
\lr{Cortex-A7}
 را انتخاب‌کردیم زیرا این پردازنده هم دارای
\lr{fpu}
 است و هم از دستورات ARM پشتیبانی می‌کند.

در کامپایلر مربوطه، تنظیمات را به گونه‌ای انجام دادیم تا به جای استفاده از عملیات اعشاری
\lr{soft-fp}ِ،
 از
\lr{hard-fp}
  استفاده‌کند که در این‌جا، به این مشکل برخوردیم که کد ما وارد 
\lr{Trap}های
\lr{CPU}
 می‌شد.

بنابراین پس از کمی جست‌وجو در منابع مختلف، متوجه‌شدیم که ابتدا باید
\lr{fpu}
 را فعال‌کنیم و بعد در ادامه به سراغ کدهای مربوطه برویم زیرا در غیر این صورت دچار مشکل خواهیم‌شد. لذا در ابتدای کدهای اسمبلی، کدی نوشتیم که
\lr{fpu}
  را فعال‌کند و به کمک آن کد، می‌توانستیم که دستورات مربوط به
\lr{fp}
 را اجرا کنیم.
 
 کد اسمبلی مذکور به شکل زیر است:
\begin{latin}
\begin{verbatim}
area start, code
export StartHere
StartHere
MRC p15, 0, r0, c1, c1, 2
ORR r0, r0, #2_11<<10 ; enable fpu
MCR p15, 0, r0, c1, c1, 2
LDR r0, =(0xF << 20)
MCR p15, 0, r0, c1, c0, 2
MOV r3, #0x40000000
VMSR FPEXC, r3
import __main
b __main
\end{verbatim}
\end{latin}
  
  حال در هر مرحله پس از اجرای هر قطعه کد مربوطه، برای بررسی درستی آن، ثبات‌ها را
\lr{pop}
   می‌کردیم و مشاهده می‌کردیم که آیا نتیجه دلخواه در درون آن‌ها ذخیره‌شده‌است یا خیر.
  

\subsubsection*{پیاده‌سازی دستورات}
حال به نحوه‌ی پیاده‌سازی دستورات این بخش می‌پردازیم:

\begin{itemize}
	
	\item\textbf{
	 دستورات 
	 \lr{fconst}
	 و
	 \lr{dconst}
}

برای پیاده‌سازی این دستورات تنها کافیست عدد مربوطه را به درون یک ثبات
\lr{mov}
 کرده و آن را به درون استک 
\lr{push}
 کنیم. توجه‌کنید که برای دستورات
\lr{floating point}
   پیش از هر دستور باید کاراکتر 
\lr{v}
 را قرار دهیم و برای اعداد
\lr{float}
   از 
   \lr{.f32}
    و برای اعداد 
\lr{double}
    از
\lr{f64.} 
    استفاده‌کنیم. نکته دیگر پیاده‌سازی این دستورات این است که مقدار صفر را نمی‌توانیم به درون یک ثبات مشخص
\lr{mov}کنیم 
      و برای این کار از عملیات
\lr{sub}
       و کم‌کردن مقدار یک ثبات از خودش برای تولید عدد صفر استفاده کرده‌ایم.
	
	\item \textbf{
		دستورات ضرب و جمع و تفریق و تقسیم
	}
	
	برای چنین عملیاتی در دستوراتی مانند dsub یا 
	\lr{fdiv}،
	ابتدا دو مقدار را از استک pop کرده و سپس عملیات مربوطه را انجام می‌دهیم و حاصل را به درون استک push می‌کنیم. این دستورات نکته خاصی ندارند و تمامی عملیات ضرب، جمع، تفریق یا تقسیم توسط coprocessor انجام می‌شوند.
	
	\item \textbf{
		دستورات مربوط به compare
	}
	
	برای 4 دستور مربوط به compare ابتدا دو عدد را با vpop از استک pop کرده و با vcmp مقایسه می‌کنیم. توجه کنید که باید به مقایسه‌کننده مخصوص دستورات
	\lr{floating point}
	متصل شویم و برای این کار از یک خط دستور زیر استفاده می‌شود.
	\begin{latin}
		\begin{verbatim}
		VMRS APSR_nzcv, FPSCR 
		\end{verbatim}
	\end{latin}
	
	پس از آن از سه بلوک مختلف استفاده می‌کنیم: بلوک
\lr{eq}،
 بلوک
 \lr{gt}
  و بلوک
\lr{lt}
 که هر یک شامل دو خط کد است و عملکرد برنامه را در صورت تساوی، بزرگ‌تر یا کوچک‌تر بودن مقایسه تعیین خواهد کرد.
	\item \textbf{
		دستورات load و store
	}
	
	در دستورات 
\lr{daload}
 و 
 \lr{faload}
  ابتدا دو عدد از استک می‌خوانیم که تعیین‌کننده محل خواندن از حافظه است. یکی از آن‌ها را به‌عنوان مبدا گرفته و دیگری را در 4 ضرب کرده و به آن می‌افزاییم تا محل خواندن عدد مربوطه به‌دست آید. سپس از محل به‌دست‌آمده در حافظه یکی از ثبات‌ها را
 \lr{load}کرده
  و حاصل را به درون استک 
\lr{push}می‌کنیم.
در دستورات
\lr{store}
 نیز کار مشابه است با این تفاوت که عددی که باید ذخیره‌شود را در ابتدا از استک خوانده و پس از آن دو عدد دیگر می‌خوانیم که به شکل ذکرشده در بالا، محل ذخیره‌سازی در حافظه را مشخص می‌کنند. در نهایت عددی که در ابتدای کار خوانده‌شد را در حافظه ذخیره می‌کنیم.
	
	\item\textbf{
		دستورات frem و fneg
	}
	
	دستور fneg بسیار ساده است. یک عدد را از درون استک pop کرده و با دستور
	\lr{vneg.f32}
	منفی کرده و در نهایت به‌درون استک push می‌کنیم. دستور frem نیز طبق فرمول ذکرشده در مراجع پیاده‌سازی شده‌است اما توجه کنید که هنگام انجام تقسیم اول که مربوط به اعداد
	\lr{floating point}
	است؛ باید حاصل را به یک integer تبدیل کنیم. برای این امر از دستور vcvt استفاده می‌کنیم که بعد از آن باید فرمت مبدا و فرمت مقصد را بنویسیم. برای مثال برای تبدیل حاصل
	\lr{floating point }
	تقسیم به عدد صحیح از دستور زیر بهره می‌گیریم که
	\lr{s32}
	نشان‌دهنده فرمت مقصد و
	\lr{f32}
	نشان‌دهنده فرمت مبدا خواهد بود.
	
	\begin{latin}
		\begin{verbatim}
		vcvt.s32.f32 s2,s2 
		\end{verbatim}
	\end{latin}
	
	\item \textbf{
		دستورات convert 
		ساده
	}
	
	دستوراتی مانند
	\lr{d2f}
	و
	\lr{f2i} 
	و 
	\lr{f2d}
	و
	\lr{d2i} 
	دستورات
	convert
	ساده هستند. 
	رای این دستورات تنها کافی‌ست از استک عدد مورد نظر را بخوانیم، به‌کمک دستور vcvt توضیح داده‌شده در بالا آن را به فرمت مورد نظر تبدیل کرده و در نهایت حاصل را به درون استک push کنیم.
	
	
	\item \textbf{
		دو دستور پیچیده تر convert
	}
	
	برای پیاده‌سازی دو دستور
	\lr{f2l}
	و
	\lr{d2l} 
	به این شکل عمل می‌کنیم که از دو خط کد آماده یافت‌شده در اینترنت برای انجام این تبدیل استفاده می‌کنیم که این دو خط کد به شکل زیر خواهد بود:
	
	
	\begin{latin}
		\begin{verbatim}
		import __aeabi_d2lz 
		bl __aeabi_d2lz
		\end{verbatim}
	\end{latin}
	
	بدیهی است که در دستورات مربوط به float به جای d از f استفاده می‌شود. سایر خطوط کد نیز نکته جدیدی ندارد.
	
	\item \textbf{
		دستورات fload
	}
	
	
	برای پیاده‌سازی دستور
	\lr{fload}،
	ابتدا یک عدد را از استک می‌خوانیم و به‌کمک شیفت چپ آن را در 4 ضرب می‌کنیم. سپس حاصل را با
	\lr{frame pointer}
	یا همان fp جمع‌کرده تا محل خواندن از حافظه به‌دست آید. سپس از محل مربوطه در حافظه خوانده و در یک ثبات ذخیره می‌کنیم و در نهایت حاصل را به درون استک، push می‌کنیم.
	
	برای دستورات
	\lr{fload\_n}
	نیز فرمت کلی زیر را داریم:
	
	\begin{latin}
		\begin{verbatim}
		vldr.f32 s0,[fp, #n*4] 
		vpush.f32 {s0}
		\end{verbatim}
	\end{latin}
	
	که به این معناست که از fp به اندازه 4 برابر n جلو می‌رویم و محتوا را از محل حافظه می‌خوانیم و در نهایت محتوای خوانده‌شده را به درون استک push می‌کنیم.
	
	\subsubsection*{اضافه‌کردن کدهای اسمبلی به 
		\lr{Instruction ROM}}
	
	حال دستورات پیاده‌سازی‌شده را هر یک به فرمت زیر می‌نویسیم:
	
	\begin{latin}
		\begin{verbatim}
		;#<instr_name> <ARM Code>
		\end{verbatim}
	\end{latin}
	
	و هدف این است که دستورات نوشته‌شده با این فرمت را به کد پایتونی که در بالا  ذکر شد بدهیم تا 
	\lr{Instruction ROM}
	را به صورت خودکار برای ما تولید کند.
\end{itemize}

\subsection*{کد پایتون و 
\lr{Assembler}
}
در کد پایتون ذکرشده،
 هر بار Assembler را صدا می‌کنیم و رشته‌های باینری مربوطه را به کمک اجرای Assembler از آن استخراج می‌کنیم تا برای ROM استفاده‌شود.

توجه‌کنید که در فاز نهایی پروژه کد پایتون مذکور را بهینه‌کرده‌ایم،سس بنابراین این کد علاوه بر این که محتوای
\lr{ROM}
 را همان‌طور که ذکر شد، تولید می‌کند؛ اگر هر کدی به آن به عنوان ورودی بدهیم، خیلی سریع کامپایل خواهد کرد و تست‌کیس مربوطه را برای ما تولید خواهدکرد. این بهینه‌سازی و فرآیند کامپایل سریع، سبب گرفتن خروجی در کمترین زمان ممکن خواهدشد و به‌وضوح کار بسیار مفیدی خواهد بود.