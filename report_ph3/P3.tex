\section*{
	برخی ماژول‌های پیاده‌سازی‌شده با
	\lr{verilog}
}

\subsection*{فایل‌های 
	\lr{memory}
}
در این فایل دو ماژول حافظه طراحی شده‌است. ماژول اول
\lr{memory\_r}
است که به عنوان ورودی سیگنال‌های کلاک
\LTRfootnote{clk}
، ریست
\LTRfootnote{reset}
، شروع
\LTRfootnote{start}
و آدرس
\LTRfootnote{address}
را می‌گیرد. در ضمن دو سیگنال خروجی داده‌ی مورد نظر
\LTRfootnote{data\_out}
و آماده‌بودن رم و جواب
\LTRfootnote{ready}
را هم داریم. حال در این ماژول، با فعال‌شدن سیگنال شروع، منتظر می‌مانیم تا سینگال 
\lr{ready}
حافظه فعال شود.
در اصل وجود
\lr{start}
و 
\lr{ready}
به شکل پیاده‌سازی‌شده برای پیاده‌سازی تاخیر حافظه بوده‌است.
به محض فعال‌شدن
\lr{ready}،
از آدرس مورد نظر، محتوا را خوانده و در 
\lr{data\_out}
خروجی می
دهیم.
ماژول دوم نیز
\lr{memory\_w}
است که برای نوشتن در حافظه استفاده می‌شود.
توجه‌کنید که در این جا دیگر لازم نیست
\lr{data\_out}
را خروجی‌دهیم و تنها هنگام
فعال‌شدنِ
\lr{start}
در حالت نوشتن، صبر می‌کنیم تا سیگنال
\lr{ready}
حافظه فعال‌شود و به محض فعال‌شدن در
\lr{address}
مورد نظر محتوای مربوطه را می‌نویسیم. توجه‌کنید که تنها تفاوت اساسی با
\lr{memory\_r}
این است که به جای خروجی
\lr{data\_out}
یک ورودی
\lr{data\_in} 
داریم که محتوایی که باید در حافظه نوشته‌شود را مشخص می‌کند.
\subsection*{
	فایل
	\lr{next\_byte\_gen.v}
}
همان‌طور که می‌دانیم؛ در پردازنده‌هایِ واقعیِ
\lr{JVM}،
هنگام خواندن و نوشتن در حافظه، با بایت سر و کار نداریم؛ بلکه برای مثال موقع خواندن یک
\lr{word}ِ
4	 بایتی از حافظه خوانده می‌شود. در بسیاری از مواقع این
\lr{word}،
شامل چندین بایت است که برای دسترسی به مواردی مانند opcode یا offset باید این بایت‌ها را جداجدا بخوانیم. برای این منظور ماژول
\lr{next\_byte\_gen}
طراحی شده‌است که یک
\lr{memory\_r}
را instantiate کرده و در صورتی که هر دو سیگنال start و ready فعال باشند؛ PC که برابر
\lr{address}ِ
حافظه‌ی instantiate شده‌است را یک واحد اضافه می‌کند که معادل یک بایت جلورفتن یا رفتن به بایت بعدی است و در صورت فعال‌بودنِ reset نیز، مقداری پیش‌فرض را برابر PC قرار خواهد داد.
\subsection*{فایل
	\lr{instruction\_ram.v}}
این ماژول نیز کار پیچیده‌ای انجام نمی‌دهد و تنها یک
\lr{word}ِ
۴ بایتی را از ورودی دریافت‌کرده و درون یک حافظه‌ی نوشتنی
\lr{(memory\_w)}
می‌نویسد. برای این کار کافیست تا هنگام instantiate کردن این حافظه درون ماژول،
\lr{data\_in}ِ
آن را برابر 
\lr{word}ِ
خوانده‌شده از ورودی قراردهیم. بدیهی‌است که سایر پارامترها نیز باید به درستی تنظیم شوند.
\subsection*{فایل‌های مربوط به 
	\lr{Decoder}}


دیکُدر طراحی‌شده در این پروژه به صورت
چند ماژول
\lr{Read Only Memory( ROM)} 
طراحی شده‌است. این 
\lr{ROM}ها
عبارتند از: 
\subsubsection*{
	\lr{Address ROM}
}
این ROM یک آدرس به عنوان ورودی گرفته و آدرس
بعدی که پس از این آدرس باید به آن برویم را برمیگرداند. 
\subsubsection*{
	\lr{Convert ROM}
}
این ROM یک آدرس را به عنوان ورودی گرفته و به عنوان
خروجی ID دستور مربوطه را به ما تحویل می‌دهد. 
\subsubsection*{
	\lr{Instruction ROM}
}
این 
\lr{ROM}،
\lr{ID}ِ
دستور را گرفته و خود دستور را به ما می
دهد. منظور از خروجی‌دادن خود دستور، پیاده‌سازی آن به صورت 0 و 1 درون ROM  است. توجه‌کنید که برای پیاده‌سازی این ROM، ابتدا دستورات پردازنده را با زبان
اسمبلی ARM نوشتیم و سپس به کمک یک قطعه‌کد پایتون به صورت خودکار آن‌ها را به فرمت کدشده 0 و 1 که باید درون این ROM نوشته‌شود؛ در می‌آوریم.
\subsection*{توضیحی درباره توالی آٓدرس‌ها}
توجه‌کنید که هنگامی که یک دستور را می خوانیم؛ ابتدا در آدرس مربوط به Opcode آن دستور قرار داریم، اما پس از آن با موارد تعیین شده در 
\lr{Address ROM}،
به صورت زنجیره‌ای (مانند یک لیست پیوندی) جلورفته و به ترتیب مجموعه عملیات مشخصی را انجام خواهیم داد. (توجه‌کنید که ممکن است یک دستور JVM به چندین دستور ARM تبدیل شود بنابراین باید زنجیره‌ای از دستورات را به ترتیب اجرا کنیم!) توجه کنید که
\lr{Convert ROM}
نیز ورودی آدرس را گرفته و یک ID را تحویل 
\lr{Instruction ROM}
می‌دهد و این ROM وظیفه اجرای دستور را خواهد داشت.

\subsection*{
	فایل
	\lr{Count ROM}}
این ROM برای این پیاده‌سازی شده‌است که مشخص‌کند پس از
خواندن Opcode یک دستور، چند بایت آینده مربوط به ادامه این دستور خواهد بود. توجه‌کنید که برخی از دستورات ممکن است تنها از یک بایت که همان Opcode است تشکیل‌شده باشند مثلا Pop ولی بسیاری از دستورات هستند که مواردی مانند یک 
\lr{Offset}
2 بایتی یا مشابه آن دارند. بنابراین
\lr{Count ROM}
با گرفتن
Opcode مشخص
می‌کند که دستور مربوطه چند بایت اضافی دارد. توجه‌کنید که در فاز اول پروژه که شامل 
$40 \%$
کار می‌شود؛ مواردی که شامل حداکثر 2 بایت اضافه باشد را Handle کرده‌ایم و تمامی موارد در فاز نهایی پروژه پیاده‌سازی خواهند شد.
\begin{itemize}
	\item[
	\danger\textbf{توجه مهم}
	]
	همان‌طور که ذکر شد؛ دستورات ممکن است پس از 
	\lr{Opcode}
	تعدادی immediate داشته باشند که پارامترهایی مانند
	\lr{index}،
	\lr{varnum}
	یا offset را مشخص کنند. برای راحتی کار، در پیاده‌سازی خود، این پارامترها را درون یکی از ثبات‌های پردازنده ARM می‌ریزیم و به درون استک Push ، ARM می‌کنیم. این کار سبب می‌شود که دیگر نیازی به انجام تغییر در
	\lr{Instruction ROM}
	نباشد و عملا پیاده‌سازی ما به مراتب راحت‌تر خواهد شد.
\end{itemize}