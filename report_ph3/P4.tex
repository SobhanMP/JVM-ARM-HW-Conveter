\section*{
ماشین حالت
\LTRfootnote{State Machine}
}
ابتدا توجه‌کنید که این ماژول یک ورودی Reset دارد که هنگام خاموش‌کردن آن، بلافاصله ثبات‌ها و پارامترهای مربوطه برای آغاز کار set می‌شوند. علاوه بر این، در ماژول
\lr{State Machine}،
ماژول
\lr{next\_byte\_gen}
را به‌عنوان
رابطی با RAM مربوط به JVM، ماژول
\lr{Instruction RAM}
را به عنوان رابطی با RAM مربوط به ARM و هم‌چنین ROM های پیاده‌سازی‌شده در Decoder به‌همراه Count ROM را قرار می‌دهیم. توجه کنید که محتوای این ROMها چگونگی جابه جایی بین Stateها را مشخص خواهد کرد.
حال پیرامون استیت‌های
\lr{State Machine}
و کاربرد هر یک
\subsubsection*{\lr{Fetch Instruction}}
این State برای خواندن یک دستور JVM از حافظه JVM طراحی شده‌است. توجه کنید که Waiting تعریف شده در ماژول 
\lr{State Machine}
برای Handle کردن تاخیر حافظه قرار داده شده‌است. به این شکل که سیگنال Ready حافظه نشان می‌دهد که آیا حافظه برای Fetch کردن دستور آماده شده‌است یا خیر. توجه کنید که قبل از فعال شدن سیگنال Ready، عملیات Fetch صورت نمی‌پذیرد و باید تا فعال‌شدن این سیگنال صبر کنیم. در صورت پایان انتظار برای حافظه، به استیت بعدی خواهیم‌رفت.

\subsubsection*{\lr{Check Wide}}
در این State بررسی می‌کنیم که دستور مورد نظر Wide است یا خیر. با مطالعه 
\lr{instruction Set}ِ
کامل
JVM 
مشاهده می‌کنیم که دستوری به نام Wide وجود دارد که به‌عنوان پیشوند قبل از برخی دستورها می‌آید و سبب می‌شود که 
\lr{index}ِ
دستورات به جای 1 بایت، 2 بایت باشد. البته در دستورات ما چنین دستوری وجود ندارد اما با توجه به این که می‌خواستیم این مورد نیز در آینده بر روی این
\lr{State Machine}
قابل پیاده‌سازی باشد؛ از یک ثبات در این استیت استفاده کردیم که در صورت Wide بودن دستور مقدار آن را یک می‌کنیم. پس از بررسی Wide بودن یا نبودن دستور، به 
\lr{State}ِ
بعدی خواهیم رفت.
\subsubsection*{\lr{Read Counter}}
این دستور به کمک
\lr{Count ROM}
بررسی می‌کند که تعداد بیت‌های مربوط به پارامترهای پس از Opcode دستور مورد نظر چند تاست. توجه‌کنید که برای افزایش سرعت کار از آنجایی که تعداد دستوراتی که اصلا پارامتری ندارند بسیار زیاد است، اگر این تعداد صفر بود،(مثلا در دستوراتی مانند DUP) بلافاصله به State بعدی خواهیم رفت. در غیر این صورت متغیر
\lr{byte\_params} 
را برابر تعداد بایت‌ها قرار داده و در
\lr{State}ِ
بعدی به سراغ Fetch کردن پارامترهای مربوط به دستور از حافظه خواهیم رفت.

\subsubsection*{\lr{Fetch Params}}
\lr{fetch}
کردن پارامترها از نظر نحوه پیاده‌سازی و شیوه‌ی انجام کار بسیار به Fetch کردن دستورات شبیه است. تنها تفاوت اساسی‌ای که وجود دارد این است که پارامترهای Fetch شده را درون ثباتی به نام 
\lr{Push Register} می‌ریزیم. این ثبات جهت مواردی مانند Push کردن پارامترها به درون استک ARM طراحی شده‌است که در صفحات قبلی توضیح دادیم.

\subsubsection*{\lr{Push to Stack}}
این استیت دو مرحله دارد، ابتدا باید 
\lr{immediate}ی
که می‌خواهد به درون استک Push شود را Load کنیم و در مرحله دوم آن را به درون استک Push کنیم. این موضوع که در کدام مرحله قرار داریم را نیز با یک بیت کنترل می‌کنیم. این بیت
\lr{push\_state}
نام دارد. توجه کنید که چنانچه
\lr{push\_state}
برابر صفر باشد؛ باید عملیات Load کردن immediate را انجام دهیم و پس از پایان آن
\lr{push\_state}
را یک خواهیم‌کرد و دوباره به همین استیت می‌رویم. در بازگشت به همین State چون
\lr{push\_state}
برابر با 1 است؛ عملیات push کردن مقدارِ لود شده به درون استک را انجام خواهیم‌داد.
\subsubsection*{\lr{Read Next}}
به کمک 
\lr{Address ROM}
در این 
\lr{State}،
آدرس بعدی را به دست می‌آوریم.
توجه‌کنید که وقتی می‌خواهیم دستور بعدی را Fetch کنیم؛ باید پیش از آن به آدرس مربوطه رفته‌باشیم که این آدرس از روی
\lr{Address ROM}
تعیین خواهدشد.
\\

توجه کنید که برخی از ماژول‌های پیاده‌سازی شده در بالا، هنوز
\lr{test}
نشده‌اند و به عبارتی
\lr{Testbench}ِ
آن‌ها نوشته نشده‌است. نوشتن این 
\lr{Testbench}ها
و تست ماژول‌ها در Integration نهایی را به
$60 \%$
پایانی پروژه موکول کرده‌ایم.
